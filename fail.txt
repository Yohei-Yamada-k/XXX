
typedef enum {
    //AD_CAN0_NODE = 0x14;
    //AD_CAN1_NODE = 0x01;
    //AD_CAN2_NODE = 0x09;
    AD_CAN3_NODE = 0x0c;
    AD_CAN4_NODE = 0x0e;
    AD_CAN5_NODE = 0x1a;
    AD_CAN6_NODE = 0x21;
} VMC_NODE_CAN_ID;

typedef enum {
    AD_CAN0_NODE = 0x14;
    //AD_CAN1_NODE = 0x01;
    AD_CAN2_NODE = 0x09;
    //AD_CAN3_NODE = 0x0c;
    //AD_CAN4_NODE = 0x0e;
    AD_CAN5_NODE = 0x1a;
    AD_CAN6_NODE = 0x21;
} TC_NODE_CAN_ID;

typedef enum {
    SYS1;
    SYS2;
    VMC;
    TC;
} MICON_TYPE;

typedef enum {
	NORMAL = 0
	CAN_SEND_FAIL,
	CAN_REV_FAIL,
	CAN_CRC_FAIL,
	CAN_SUM_FAIL,
	CAN_CLOCK_FAIL
} FAIL_CODE;

    static struct CanSend_st{
            CAN_ID TemporaryCanID,
            FAIL_SAFE_TABLE FailSafe,
            int Fail_Cnt,
        } CanSendInfo[] = {
            {can_send_1, CAN_SEND_FAIL, false}
            {can_send_2, CAN_SEND_FAIL, false}
            {can_rev_1, CAN_REV_FAIL, false}
            {can_rev_2, CAN_REV_FAIL, false}
            {can_sum_1, CAN_SUM_FAIL, false}
            {can_clock_1, CAN_CLOCK_FAIL, false}
        }


#define ARRAY_LENGTH(array) (sizeof(array) / sizeof(array[0]))
int const Fail_Cnt_th = 10;
static int Can_Send_Cnt  = 0;
static int Can_Rev_Cnt   = 0;
static Can_Fail_Flag = false; // MsgInfoに依存しない、共通なFlag
int Fail_State[] ={};

/* 入力判定部 */
bool Call_CanAPI(CAN_ID_TABLE const CanID){
	bool API_CanID = API(CanID);
	return API_CanID;
}

/* 異常判定部 */
// Call_Fail_Cnt(FAIL_CODE Fail_Code, int Tmp_Cnt, bool Tmp_Flag)
Call_Fail_Cnt(struct* const TmpStruct, int index)
{
	if(TmpStruct[index]->Fail_Flag)
	{
        TmpStruct[index]->Fail_Cnt++;
            if(TmpStruct[index]->Fail_Cnt > Fail_Cnt_th)
            {
                Can_Fail_Flag = true; // info毎に分けた方がよさそう…

                /* データ生成 */
                switch(TmpStruct[index]->.Fail_Code)
                {
                    case CAN_SEND_FAIL:
                        CanSendFailSet(); 
                        break;
                        
                    case CAN_REV_FAIL:
                        CanRevFailSet();
                        break;
                        
                    case CAN_CRC_FAIL:
                        CanCRCFailSet();
                        break;
                        
                    case CAN_SUM_FAIL: // Canサムチェック診断処理
                        Fail_State[CAN_SUM_FAIL] = 0xFFFE;
                        break;
                        
                    case CAN_CLOCK_FAIL: // CanClock信診断処理
                        Fail_State[CAN_SUM_FAIL] = 0xFFFE;
                        break;
                        
                    defalt:
                        break;
                }
            }
        }
        else {
            // 異常カウントをクリアする
            if(TmpStruct[index]->Fail_Cnt != 0)
            {
                TmpStruct[index]->Fail_Cnt = 0;
            }
        }





void f_CanSend_set(MICON_TYPE)
{
    CanSendCmd[] = {Invalid, cmd1, cmd2, cmd3};
    CanSendCmd[MICON_TYPE]



    static CanSend_st CanSendType[XXX] = 
    
	if(!Can_Fail_Flag)
	{
		// Do Nathing
		// 異常判定
	}
	else {
		for(int i=0; i < ARRAY_LENGTH(MsgIDTable); i++)
		{
			/* 入力判定部 */
			MsgIDTable[i].Fail_Flag = Call_CanAPI(MsgIDTable[i].Can_ID_Table);

			/* 異常判定部 */
			Call_Fail_Cnt(MsgIDTable, i)
					//	MsgIDTable[i].Fail_Code,
					//	MsgIDTable[i].Fail_Cnt,
					//	MsgIDTable[i].Fail_Flag
		}

		for(int i=0; i < ARRAY_LENGTH(MsgIDTable); i++)
		{
			/* 入力判定部 */
			Call_CanAPI(int* i)

			/* 異常判定部 */
			Call_Fail_Cnt();
		}
	}

	if(!CanFailFlag)
	{
		NormalSet();
	}
	else 
	{
		// Do Nathing
	}

	// 出力処理
}

int Cmd1(){
    Cmd1Tabale[] = {
        AD_CAN3_NODE,
        AD_CAN4_NODE,
        AD_CAN5_NODE,
    };
    return 0;
}
